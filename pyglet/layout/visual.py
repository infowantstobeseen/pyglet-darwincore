#!/usr/bin/env python

'''Format CSS boxes into frames and control rendering.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id$'

from pyglet.layout.base import *

class ContainingBlock(object):
    '''A rectangular region in which boxes are placed.

    Described in 9.1.2.
    '''
    def __init__(self, left, top, right, bottom):
        self.left = left
        self.top = top
        self.right = right
        self.bottom = bottom

    def get_width(self):
        return self.right - self.left
    width = property(get_width)

    def get_height(self):
        return self.bottom - self.top
    height = property(get_height)

    def __repr__(self):
        return '%s(%d,%d -- %d,%d)' % (self.__class__.__name__,
            self.left, self.top, self.right, self.bottom)

class PositionedFrame(object):
    '''Abstract positioned, renderable box.

    Boxes are sometimes split into several frames (for example, during line
    breaking).  The 'continuation' attribute links to the next Frame that was
    generated by the same box.
    
    All properties assigned to a frame are the "used" values.
    '''
    box = None
    parent = None
    continuation = None 

    # Box model properties
    used_margin_top = 0
    used_margin_right = 0
    used_margin_bottom = 0
    used_margin_left = 0
    used_padding_top = 0
    used_padding_right = 0
    used_padding_bottom = 0
    used_padding_left = 0
    used_border_top = 0
    used_border_right = 0
    used_border_bottom = 0
    used_border_left = 0
    used_width = 0
    used_min_width = 0
    used_max_width = 0
    used_height = 0
    used_min_height = 0
    used_max_height = 0
    used_top = 0
    used_right = 0
    used_bottom = 0
    used_left = 0

    # Border edge, relative to parent's content area
    border_edge_left = 0
    border_edge_top = 0
    border_edge_width = 0
    border_edge_height = 0

    def __init__(self, box, parent, containing_block):
        assert isinstance(box, Box)
        assert isinstance(parent, FrameContainer)
        assert isinstance(containing_block, ContainingBlock)
        self.box = box
        self.parent = parent
        self.containing_block = containing_block
        self.resolve_used_values()
        
    def resolve_used_values(self):
        '''Set the 'used' attributes on this frame from its box, resolving
        percentages relative to the containing block where appropriate.
        '''
        def resolve(value, reference):
            if type(value) == Percentage:
                return value * reference
            return value

        # Resolve border widths.
        self.used_border_top = max(self.box.border_top_width, 0)
        self.used_border_right = max(self.box.border_right_width, 0)
        self.used_border_bottom = max(self.box.border_bottom_width, 0)
        self.used_border_left = max(self.box.border_left_width, 0)

        # Resolve percentage widths.
        width = self.containing_block.width
        self.used_margin_top = resolve(self.box.margin_top, width)
        self.used_margin_right = resolve(self.box.margin_right, width)
        self.used_margin_bottom = resolve(self.box.margin_bottom, width)
        self.used_margin_left = resolve(self.box.margin_left, width)
        self.used_padding_top = max(resolve(self.box.padding_top, width), 0)
        self.used_padding_right = max(resolve(self.box.padding_right, width), 0)
        self.used_padding_bottom = max(resolve(self.box.padding_bottom,width),0)
        self.used_padding_left = max(resolve(self.box.padding_left, width), 0)
        self.used_width = resolve(self.box.width, width)
        self.used_min_width = resolve(self.box.min_width, width)
        self.used_max_width = resolve(self.box.max_width, width)

        # Resolve percentage heights.
        height = self.containing_block.height
        self.used_height = resolve(self.box.height, height)
        self.used_min_height = resolve(self.box.min_height, height)
        self.used_max_height = resolve(self.box.max_height, height)

        # Cannot resolve top/left/bottom/right yet; they require
        # containing block to be complete.
        # Note that position:relative only needs top and left.
        self.used_top = self.box.top
        self.used_right = self.box.right
        self.used_bottom = self.box.bottom
        self.used_left = self.box.left

    def resolve_auto_widths(self):
        '''Apply the rules from 10.3 to resolve any 'auto' width-based values
        in the used attributes.
        '''
        raise NotImplementedError('abstract')

    def resolve_auto_heights(self):
        '''Apply the rules from 10.3 to resolve any 'auto' height-based values
        in the used attributes.
        '''
        raise NotImplementedError('abstract')

    def resolve_min_max_width(self):
        if self.used_max_width != 'none' and \
           self.used_width > self.used_max_width:
            self.used_width = self.used_max_width
            self.resolve_auto_widths()
        if self.used_width < self.used_min_width:
            self.used_width = self.used_min_width
            self.resolve_auto_widths()

    def resolve_min_max_height(self):
        if self.used_max_height != 'none' and \
           self.used_height > self.used_max_height:
            self.used_height = self.used_max_height
            self.resolve_auto_heights()
        if self.used_height < self.used_min_height:
            self.used_height = self.used_min_height
            self.resolve_auto_heights()

    def create_continuation(self):
        '''Create a continuation for this frame.
        '''
        assert not self.continuation
        self.continuation = \
            self.__class__(self.box, self.parent, self.containing_block)

    def draw_background(self, render_device, x, y):
        '''Draw the background of this frame with the border-edge top-left at
        the given coordinates.'''
        if self.box.background_color == 'transparent' and \
           self.box.background_image == 'none':
            return
        render_device.draw_background(
            x,
            y,
            x + self.border_edge_width,
            y - self.border_edge_height,
            self.box)

    def draw_border(self, render_device, x, y):
        '''Draw the border of this frame with the border-edge top-left at the
        given coordinates.
        
        Each border edge is drawn as a trapezoid.  The render device takes
        care of applying the border style if it is not 'none'.
        '''
        x2 = x + self.border_edge_width
        y2 = y - self.border_edge_height
        if self.used_border_top:
            render_device.draw_horizontal_border(
                x + self.used_border_left, y - self.used_border_top,
                x2 - self.used_border_right, y - self.used_border_top,
                x2, y,
                x, y, 
                self.box.border_top_color, self.box.border_top_style)
        if self.used_border_right:
            render_device.draw_vertical_border(
                x2 - self.used_border_right, y - self.used_border_top,
                x2 - self.used_border_right, y2 + self.used_border_bottom,
                x2, y2,
                x2, y,
                self.box.border_right_color, self.box.border_right_style)
        if self.used_border_bottom:
            render_device.draw_horizontal_border(
                x + self.used_border_left, y2 + self.used_border_bottom,
                x2 - self.used_border_right, y2 + self.used_border_bottom,
                x2, y2,
                x, y2,
                self.box.border_bottom_color, self.box.border_bottom_style)
        if self.used_border_left:
            render_device.draw_vertical_border(
                x + self.used_border_left, y - self.used_border_top,
                x + self.used_border_left, y2 + self.used_border_bottom,
                x, y2,
                x, y,
                self.box.border_left_color, self.box.border_left_style)

    def draw(self, render_device, x, y):
        '''Draw this frame with the border-edge top-left at the given
        coordinates.
        
        Also take this opportunity to resolve used values for percentage 
        left/top/right/bottom.
        '''
        if type(self.used_top) == Percentage:
            self.used_top = self.containing_block.height * self.used_top
        if type(self.used_left) == Percentage:
            self.used_left = self.containing_block.height * self.used_left
        x += self.used_left
        y -= self.used_top
        self.draw_background(render_device, x, y)
        self.draw_border(render_device, x, y)

class InlinePositionedFrame(PositionedFrame):
    '''Abstract frame that can be positioned within an InlineFrameContainer.
    '''

    line_ascent = 0             # Ascent/descent of line-height
    line_descent = 0
    content_ascent = 0          # Ascent/descent of content area
    content_descent = 0
    left_parent_bearing = 0     # Add margin for parent edges.
    right_parent_bearing = 0
    margin_edge_width = 0       # All margins, border and padding 

    def resolve_line_height(self, line_ascent, line_descent):
        if self.box.vertical_align in ('baseline', 'bottom', 'text-bottom'):
            self.line_ascent = line_ascent
            self.line_descent = line_descent
        elif self.box.vertical_align in ('top', 'text-top'):
            self.line_ascent = line_ascent - line_descent
            self.line_descent = 0
        elif self.box.vertical_align == 'middle':
            parent_middle = self.parent.box.font_size / 2.
            height = line_ascent - line_descent
            self.line_ascent = parent_middle + height / 2
            self.line_descent = parent_middle - height / 2
        
    def vertical_align(self, line_box_top, parent_baseline, line_box_bottom):
        if self.box.vertical_align == 'baseline':
            self.border_edge_top = parent_baseline - self.content_ascent + \
                self.used_margin_top
        elif self.box.vertical_align == 'top':
            self.border_edge_top = line_box_top + self.used_margin_top
        else:
            raise NotImplementedError()

class BlockPositionedFrame(PositionedFrame):
    '''Abstract frame that can be positioned within a BlockFrameContainer.
    '''

class FrameContainer(object):
    '''Abstract frame that can contain other frames.
    '''
    children = None

    def __init__(self):
        self.children = []

    def add(self, frame):
        '''Add the frame to the end of this container.
        '''
        assert frame not in self.children
        self.children.append(frame)

    def insert_after(self, reference, frame):
        '''Add the frame to this container after 'reference', which already
        exists in this container.
        '''
        assert reference in self.children
        assert frame not in self.children
        index = self.children.index(reference)
        self.children.insert(index + 1, frame) 

    def split(self, break_frame=None):
        '''Create a continuation for this frame.

        If break_frame is specified, that frame (which is a child of this
        container) and all frames after it are moved into the continuing
        frame.
        '''
        if break_frame:
            assert break_frame in self.children
            index = self.children.index(break_frame)
        else:
            index = len(self.children)

        self.create_continuation()
        self.continuation.children = self.children[index:]
        for child in self.continuation.children:
            child.parent = self.continuation
        self.children = self.children[:index]

        # XXX Problem when inline split propogates above LineBoxFrame... at the
        # moment only propogate to InlineFrameContainer, but in future need to
        # handle block splits for page breaks as well.
        if self.parent and isinstance(self.parent, InlineFrameContainer):
            self.parent.insert_after(self, self.continuation)
            self.parent.split(self.continuation)

    def draw(self, render_device, x, y):
        # Depend on PositionFrame.draw() being called first, as this resolves
        # percentage used_left/top
        if isinstance(self, PositionedFrame): # yuk
            x += self.used_left
            y -= self.used_top
        for child in self.children:
            child.draw(render_device, 
                       x + child.border_edge_left,
                       y - child.border_edge_top)
        

class BlockFrameContainer(FrameContainer):
    '''Abstract frame that can contain block frames.
    '''
    def __init__(self, generated_containing_block):
        super(BlockFrameContainer, self).__init__()
        self.generated_containing_block = generated_containing_block

class InlineFrameContainer(FrameContainer):
    '''Abstract frame that can contain inline frames.
    '''
    pass

class BlockFrame(BlockPositionedFrame, BlockFrameContainer):
    '''Frame for boxes with display: block
    '''
    def __init__(self, box, parent, containing_block):
        BlockPositionedFrame.__init__(self, box, parent, containing_block)
        self.resolve_auto_widths()
        self.resolve_min_max_width()
        generated_containing_block = ContainingBlock(
           self.used_border_left + self.used_padding_left,
           self.used_border_top + self.used_padding_top,
           self.used_border_left + self.used_padding_left + self.used_width,
           self.used_border_top  + self.used_padding_top)
        BlockFrameContainer.__init__(self, generated_containing_block)
        
    def resolve_used_values(self):
        # TODO See if containing block height depends on content.  See 10.5
        # TODO Don't do this for absolutely positioned blocks.
        # TODO Don't do this for the root element (is relative to initial
        # containing block).
        if type(self.used_height) == Percentage:
            self.used_height = Ident('auto')
        super(BlockFrame, self).resolve_used_values()

    def resolve_auto_widths(self):
        # Width and left/right margins, described in 10.3.3
        auto_margin_left = auto_margin_right = False
        if self.used_margin_left == 'auto':
            auto_margin_left = True
            self.used_margin_left = 0
        if self.used_margin_right == 'auto':
            auto_margin_right = True
            self.used_margin_right = 0
        non_content_width = self.used_margin_left + self.used_padding_left + \
            self.used_border_left + self.used_border_right + \
            self.used_padding_right + self.used_margin_right
        remaining_width = self.containing_block.width - non_content_width

        if self.used_width == 'auto':
            self.used_width = self.containing_block.width - non_content_width
        else:
            if not auto_margin_left and not auto_margin_right:
                # Over-constrained
                if self.box.direction == 'ltr':
                    auto_margin_right = True
                else:
                    auto_margin_left = True

            # Distribute remaining space over all 'auto' margins
            if auto_margin_left and auto_margin_right:
                self.used_margin_left = remaining_width / 2
                self.used_margin_right = remaining_width / 2
            elif auto_margin_left:
                self.used_margin_left = remaining_width
            else:
                self.used_margin_right = remaining_width
        self.border_edge_width = self.used_border_left + \
            self.used_padding_left + self.used_width + \
            self.used_padding_right + self.used_border_right

    def resolve_auto_heights(self):
        if self.used_height == 'auto':
            self.used_height = self.generated_containing_block.height
        self.border_edge_height = self.used_border_top + \
            self.used_padding_top + self.used_height + \
            self.used_padding_bottom + self.used_border_bottom

    def draw(self, render_device, x, y):
        BlockPositionedFrame.draw(self, render_device, x, y)
        BlockFrameContainer.draw(self, render_device, x, y)

class InlineFrame(InlinePositionedFrame, InlineFrameContainer):
    '''Frame for boxes with display: inline 
    '''
    def __init__(self, box, parent, containing_block):
        InlinePositionedFrame.__init__(self, box, parent, containing_block)
        InlineFrameContainer.__init__(self)

    def create_continuation(self):
        super(InlineFrame, self).create_continuation()
        self.continuation.right_parent_bearing = self.right_parent_bearing
        self.right_parent_bearing = 0

        self.used_margin_right = 0
        self.used_padding_right = 0
        self.used_border_right = 0
        self.continuation.used_margin_left = 0
        self.continuation.used_padding_left = 0
        self.continuation.used_border_left = 0

    def resolve_auto_widths(self):
        x = self.used_border_left + self.used_padding_left
        for frame in self.children:
            frame.resolve_auto_widths()
            frame.resolve_min_max_width()
            frame.border_edge_left = x + frame.used_margin_left
            x += frame.margin_edge_width
        self.margin_edge_width = x
        self.border_edge_width = x + self.used_border_left + \
            self.used_padding_left + self.used_padding_right + \
            self.used_border_right

    def resolve_auto_heights(self):
        self.used_margin_top = 0
        self.used_margin_bottom = 0

        self.content_ascent = self.content_descent = 0
        line_ascent = line_descent = 0
        for frame in self.children:
            frame.resolve_auto_heights()
            frame.resolve_min_max_height()
            self.content_ascent = max(self.content_ascent, frame.content_ascent)
            self.content_descent = min(self.content_descent,frame.content_descent)
            line_ascent = max(line_ascent, frame.line_ascent)
            line_descent = min(line_descent, frame.line_descent)
        self.content_ascent += self.used_padding_top + self.used_border_top
        self.content_descent -= self.used_padding_bottom + self.used_border_bottom
        self.resolve_line_height(line_ascent, line_descent)
        self.used_height = self.content_ascent - self.content_descent
        self.border_edge_height = self.used_height

    def vertical_align(self, line_box_top, parent_baseline, line_box_bottom):
        super(InlineFrame, self).vertical_align(line_box_top,
            parent_baseline, line_box_bottom)
        line_box_top -= self.border_edge_top
        line_box_bottom -= self.border_edge_top
        baseline = self.content_ascent
        for frame in self.children:
            frame.vertical_align(line_box_top, baseline, line_box_bottom)

    def draw(self, render_device, x, y):
        InlinePositionedFrame.draw(self, render_device, x, y)
        InlineFrameContainer.draw(self, render_device, x, y)

class TextFrame(InlinePositionedFrame):
    '''Frame for non-replaced inline elements containing text.
    '''

    # Subclasses must resolve these before calling this class's __init__.
    text_width = 0
    text_ascent = 0
    text_descent = 0

    def __init__(self, box, parent, containing_block, text):
        super(TextFrame, self).__init__(box, parent, containing_block)
        self.text = text

        # 10.3.1
        if self.used_margin_left == 'auto':
            self.used_margin_left = 0
        if self.used_margin_right == 'auto':
            self.used_margin_right = 0
        self.used_margin_top = 0
        self.used_margin_bottom = 0
        self.used_width = self.text_width

    def resolve_auto_widths(self):
        self.border_edge_width = self.used_padding_left + \
            self.used_border_left + self.used_width + \
            self.used_border_right + self.used_padding_right
        self.margin_edge_width = self.used_margin_left + \
             self.border_edge_width + self.used_margin_right

    def resolve_min_max_width(self):
        pass

    def resolve_auto_heights(self):
        self.content_ascent = line_ascent = self.text_ascent
        self.content_descent = line_descent = self.text_descent
        if self.box.line_height != 'normal':
            half_leading = (self.box.line_height - 
                            (line_ascent - line_descent)) / 2
            line_ascent += half_leading
            line_descent -= half_leading
        self.resolve_line_height(line_ascent, line_descent)
        self.used_height = self.content_ascent - self.content_descent
        self.border_edge_height = self.used_border_top + \
            self.used_padding_top + self.used_height + \
            self.used_padding_bottom + self.used_border_bottom

    def resolve_min_max_height(self):
        pass

    def lstrip(self):
        pass # TODO

    def draw(self, render_device, x, y):
        super(TextFrame, self).draw(render_device, x, y)
        x += self.used_left
        y -= self.used_top
        self.draw_text(render_device, x, y - self.content_ascent)

    def draw_text(self, render_device, x, y):
        '''Subclasses must override to draw glyphs.  x,y give position
        of baseline.'''
        raise NotImplementedError('abstract')

    def __repr__(self):
        return 'TextFrame(%r)' % self.text

class ReplacedInlineFrame(InlinePositionedFrame):
    '''Frame for replaced inline elements.

    The constraint resolution for replaced boxes with auto width and height
    and intrinsic ratio specified in the table in 10.4 is not implemented. 
    '''
    def resolve_auto_widths(self):
        # 10.3.2
        if self.used_margin_left == 'auto':
            self.used_margin_left = 0
        if self.used_margin_right == 'auto':
            self.used_margin_right = 0

        if self.used_width == 'auto':
            if self.used_height == 'auto':
                if self.box.intrinsic_width is not None:
                    self.used_width = self.box.intrinsic_width
                elif (self.box.intrinsic_height is not None and
                      self.box.intrinsic_ratio is not None):
                    self.used_width = self.box.intrinsic_height * \
                        self.box.intrinsic_ratio
            elif self.box.intrinsic_ratio is not None:
                self.used_width = self.used_height * self.box.intrinsic_ratio

        if self.used_width == 'auto':
            assert False, 'auto width and no intrinsic size must be resolved\
                in formatter'
            self.used_width = 0

        self.border_edge_width = self.used_border_left + \
            self.used_padding_left + self.used_width +  \
            self.used_padding_right + self.used_border_right

        self.margin_edge_width = self.used_margin_left + \
             self.border_edge_width + self.used_margin_right

    def resolve_auto_heights(self):
        # 10.6.2
        if self.used_margin_top == 'auto':
            self.used_margin_top = 0
        if self.used_margin_bottom == 'auto':
            self.used_margin_bottom = 0

        if self.used_height == 'auto':
            if self.used_width == 'auto':
                assert False, 'expected auto width to be resolved before height'
            elif self.box.intrinsic_ratio is not None:
                self.used_height = self.used_width / self.box.intrinsic_ratio

        if self.used_height == 'auto':
            assert False, 'auto width and no intrinsic size must be resolved\
                in formatter'
            self.used_height = 0

        self.border_edge_height = self.used_border_top + \
            self.used_padding_top + self.used_height + \
            self.used_padding_bottom + self.used_border_bottom

        self.content_ascent = self.border_edge_height + \
            self.used_margin_bottom + self.used_margin_top
        self.content_descent = 0
        self.resolve_line_height(self.content_ascent, 0)

    def draw(self, render_device, x, y):
        super(ReplacedInlineFrame, self).draw(render_device, x, y)
        x += self.used_border_left + self.used_padding_left + self.used_left
        y -= self.used_border_top + self.used_padding_top - self.used_top
        x2 = x + self.used_width
        y2 = y - self.used_height
        self.box.draw(render_device, x, y, x2, y2)
        

class LineBoxFrame(BlockPositionedFrame, InlineFrameContainer):
    '''Frame for assembling inline boxes into lines.
    '''
    def __init__(self, box, parent, containing_block):
        BlockPositionedFrame.__init__(self, box, parent, containing_block)
        InlineFrameContainer.__init__(self)
        self.border_edge_left = containing_block.left
        self.remaining_width = containing_block.width

    def can_add(self, frame):
        return len(self.children) == 0 or \
            (self.remaining_width >= frame.margin_edge_width + 
                frame.left_parent_bearing + frame.right_parent_bearing)

    def use_width(self, frame):
        self.remaining_width -= frame.margin_edge_width + \
            frame.left_parent_bearing + frame.right_parent_bearing

    def is_empty(self):
        return self.remaining_width == self.containing_block.width

    def resolve_used_values(self):
        pass

    def resolve_auto_widths(self):
        pass

    def resolve_auto_heights(self):
        pass

    def resolve_min_max_width(self):
        pass

    def resolve_min_max_height(self):
        pass

    def close(self):
        '''Align children horizontally and vertically.
        '''
        if self.box.text_align == 'justify':
            raise NotImplementedError()

    def position_children(self):
        '''Align and justify child frames.
        '''
        # Determine line height 
        line_ascent = 0
        line_descent = 0
        for frame in self.children:
            frame.resolve_auto_widths()
            frame.resolve_min_max_width()
            frame.resolve_auto_heights()
            frame.resolve_min_max_height()
            line_ascent = max(line_ascent, frame.line_ascent)
            line_descent = min(line_descent, frame.line_descent)
        
        # Apply minimum line-height property.
        if self.box.line_height != 'normal':
            self.used_height = self.border_edge_height = \
                max(line_ascent - line_descent, self.box.line_height)
            half_leading = (self.used_height - (line_ascent - line_descent)) / 2
            line_ascent += half_leading
            line_descent -= half_leading
        else:
            self.used_height = self.border_edge_height = \
                line_ascent - line_descent
            
        # Position children
        x = 0
        for frame in self.children:
            frame.vertical_align(0, line_ascent, self.used_height)
            frame.border_edge_left = x + frame.used_margin_left
            x += frame.margin_edge_width

        # XXX keep this for glyph positioning hack only.
        self.line_ascent = line_ascent

    def draw(self, render_device, x, y):
        # XXX integer glyph positioning hack.
        frac = (y - self.line_ascent) - int(y - self.line_ascent) 
        y -= frac

        InlineFrameContainer.draw(self, render_device, x, y)

class ViewportFrame(BlockFrameContainer):
    '''Root frame.
    '''

class FormattingContext(object):
    '''Context in which frames are assembled from boxes.
    '''
    def add(self, box):
        '''Flow the given box into the layout, creating frames as necessary.
        '''
        pass

    def close(self):
        '''Guarantee that no more boxes will be added.  Required in order
        to finalise flow layout.
        '''
        pass

class BlockFormattingContext(FormattingContext):
    '''Formatting context for creating block frames and assembling them into
    block containers.

    Behaviour is specified in 9.4.1.
    '''

    def __init__(self, containing_frame, containing_block):
        self.frame_stack = [containing_frame]
        self.containing_block_stack = [containing_block]
        self.current_margin = 0

    def add(self, box):
        assert box.display == 'block'
        frame = BlockFrame(box, self.frame_stack[-1],
            self.containing_block_stack[-1])
        
        # Collapse top margin
        '''
        top = self.containing_block_stack[-1].bottom + \
              frame.used_margin_top
        margin = max(frame.used_margin_top, self.current_margin)
        top -= margin - self.current_margin
        '''
        top = self.containing_block_stack[-1].bottom
        margin = max(frame.used_margin_top, self.current_margin)
        top += margin - self.current_margin
        self.current_margin = margin

        # Add frame to layout and update current margin
        self.frame_stack[-1].add(frame)
        frame.border_edge_top = top
        frame.border_edge_left = frame.used_margin_left

        # Don't collapse margin through padding or border.
        if frame.used_border_top or frame.used_padding_top:
            self.current_margin = 0

        if box.children or box.text:
            self.frame_stack.append(frame)
            self.containing_block_stack.append(frame.generated_containing_block)

            if box.inline_formatting_context:
                context = InlineFormattingContext(frame, 
                    self.containing_block_stack[-1], box)
                for child in box.children:
                    context.add(child)
                context.close()
            else:
                for child in box.children:
                    self.add(child)

            self.frame_stack.pop()
            self.containing_block_stack.pop()
    
        # Fix height of the frame and set border_height.
        frame.resolve_auto_heights()
        frame.resolve_min_max_height()
        frame.border_edge_height = frame.used_border_top + \
            frame.used_padding_top + frame.used_height + \
            frame.used_padding_bottom + frame.used_border_bottom

        # Don't collapse margin through content.
        if frame.used_height > 0:
            self.current_margin = 0

        # Don't collapse margin through padding or border.
        if frame.used_border_bottom or frame.used_padding_bottom:
            self.current_margin = 0

        # Collapse bottom margin
        bottom = frame.border_edge_top + frame.border_edge_height
        margin = max(self.current_margin, frame.used_margin_bottom)
        bottom += margin - self.current_margin
        self.current_margin = margin
        self.containing_block_stack[-1].bottom = bottom

    def close(self):
        assert len(self.frame_stack) == 1
   
class InlineFormattingContext(FormattingContext):
    '''Formatting context for creating inline frames and assembling them
    into line boxes.

    Mostly defined by 9.4.2.

    We don't implement the Unicode line-breaking algorithm because it's

    a) complex and
    b) not required by CSS and
    c) stupid (see http://www.cs.tut.fi/~jkorpela/unicode/linebr.html
       for a critique).
     
    Instead, we break by replacing any of the following characters
    with a line-break:
     * U+0020  SPACE
     * U+200B  ZERO WIDTH SPACE
     
    Line breaks are forced at
     * U+000A  (line feed)
     
    It is up to the formatter to generate boxes with these contents.
    The formatter can do this by implementing 16.6.1.
    '''

    def __init__(self, containing_frame, containing_block, box):
        self.containing_frame = containing_frame
        self.containing_block = containing_block
        self.line_box = LineBoxFrame(box, containing_frame, containing_block)
        self.frame_stack = [self.line_box]
        self.break_frame = None
        self.break_at_end = False
        
    def add(self, box, space_left=0, space_right=0):
        if box.children:
            frame = InlineFrame(box, self.frame_stack[-1], 
                self.containing_block)
            self.break_at_end = False

            # Make room for this (parent) frame's border, padding and margin
            space_left += (
                frame.used_margin_left +
                frame.used_padding_left +
                frame.used_border_left)
            space_right += (
                frame.used_margin_right +
                frame.used_padding_right +
                frame.used_border_right)

            # Add frame to parent
            self.frame_stack[-1].add(frame)

            # Create frame's children.
            self.frame_stack.append(frame)
            for child in box.children[:-1]:
                self.add(child, space_left, 0)
                space_left = 0
            self.add(box.children[-1], space_left, space_right)
            self.frame_stack.pop()

        elif box.text:
            text = box.text
            from_breakpoint = 0
            frame_open = True
            frame_close = False

            # Create a temporary inline frame so we can measure left/right
            # margin/padding/border requirements.
            temp = InlineFrame(
                box, self.frame_stack[-1], self.containing_block)
            inner_space_left = \
                temp.used_margin_left + temp.used_border_left + \
                temp.used_padding_left
            inner_space_right = \
                temp.used_margin_right + temp.used_border_right + \
                temp.used_padding_right
            del temp
            
            while from_breakpoint < len(text):
                remaining_width = self.line_box.remaining_width - \
                    (space_right + inner_space_right)
                if frame_open:
                    remaining_width -= space_left + inner_space_left

                frame = box.font.create_text_frame(
                    box, self.frame_stack[-1], self.containing_block,
                    text[from_breakpoint:], remaining_width)

                if not frame.text:
                    break

                # Uses the last part of text?
                frame_close = from_breakpoint + len(frame.text) == len(text)
                if frame_open:
                    frame.left_parent_bearing = space_left
                else:
                    frame.used_margin_left = 0
                    frame.used_border_left = 0
                    frame.used_padding_left = 0
                if frame_close:
                    frame.right_parent_bearing = space_right
                else:
                    frame.used_margin_right = 0
                    frame.used_border_right = 0
                    frame.used_padding_right = 0

                frame.resolve_auto_widths()
                
                # If the frame won't fit on this line, and it's possible to
                # break the current line, break it.
                if not self.line_box.can_add(frame) and \
                       (self.break_at_end or self.break_frame) and \
                       box.white_space != 'nowrap':
                    self.line_break()
                    continue
                
                # If this box comes after a breakpoint, set this box to be
                # the break_frame, in case a line break is needed later.
                if from_breakpoint != 0:
                    self.break_frame = frame

                # Add this frame to the line
                self.frame_stack[-1].add(frame)
                self.line_box.use_width(frame)
                frame.parent = self.frame_stack[-1] # necessary?
                frame_open = False

                if frame.hard_break:
                    from_breakpoint += 1
                    self.break_at_end = True
                    self.line_break()
                elif frame.text[-1] not in u'\n\u0020\u200b':
                    # If that was the last frame for the line, make sure we
                    # don't break after it.
                    self.break_at_end = False
                else:
                    # Otherwise (more frames coming), allow a break after this
                    # frame, and get ready to go again.
                    self.break_at_end = True
                from_breakpoint += len(frame.text)
        elif box.is_replaced:
            # Not text (replaced element), cannot be broken.  Assume we can
            # break around it though (CSS doesn't specify).
            frame = ReplacedInlineFrame(box, self.frame_stack[-1],
                self.containing_block)
            frame.resolve_auto_widths()
            frame.resolve_auto_heights()
            # TODO left/right bearings
            if not self.line_box.can_add(frame) and \
                    (self.break_at_end or self.break_frame):
                self.line_break()
            self.frame_stack[-1].add(frame)
            self.line_box.use_width(frame)
            self.break_at_end = True
        else:
            # Empty element not handled yet
            pass

    def line_break(self):
        assert not self.line_box.continuation

        if self.break_at_end:
            self.frame_stack[-1].split(None)
        else:
            self.break_frame.parent.split(self.break_frame)
        
        self.add_line_box(self.line_box)

        self.line_box = self.line_box.continuation

        # lstrip the first text child in line_box, if there is one
        frame = self.line_box
        while isinstance(frame, InlineFrameContainer) and frame.children:
            frame = frame.children[0]
        if (isinstance(frame, TextFrame) and 
            frame.box.white_space in ('normal', 'nowrap', 'pre-line')):
            frame.lstrip() 
            # TODO: need to recalculate something now?

        # Adds after this line break should go into the latest continuation.
        self.frame_stack = [f.continuation or f for f in self.frame_stack]
        self.break_frame = None
        self.break_at_end = False
 
    def add_line_box(self, line_box):
        '''Add the given LineBoxFrame to the block container.  Note that this
        formatting context takes frames, not boxes.
        '''
        assert isinstance(line_box, LineBoxFrame)

        line_box.position_children()
        self.containing_frame.add(line_box)

        line_box.border_edge_top = self.containing_block.bottom
        self.containing_block.bottom += line_box.used_height

    def close(self):
        self.add_line_box(self.line_box)

class VisualLayout(object):
    def __init__(self, render_device):
        self.render_device = render_device
        self.root_frame = None

    def draw(self):
        self.draw_viewport(0, 0, 
            self.render_device.width, self.render_device.height)

    def draw_viewport(self, 
                      viewport_left, viewport_top, 
                      viewport_right, viewport_bottom):
        self.root_frame.draw(self.render_device, 0, 0)

    def set_root(self, box):
        self.root_box = box

    def layout(self):
        # Not specified in CSS spec, we're going to force it.  Shouldn't
        # make any difference block/inline.  Other options don't make much
        # sense.  TODO Could create an anonymous block box if necessary.
        self.root_box.display = 'block'

        self.root_frame = ViewportFrame(self.initial_containing_block)
        context = BlockFormattingContext(
            self.root_frame, self.initial_containing_block())
        context.add(self.root_box)
        context.close()
    
    def initial_containing_block(self):
        return ContainingBlock(0, 0, 
            self.render_device.width, 0)
            #self.render_device.height) # XXX HACK


